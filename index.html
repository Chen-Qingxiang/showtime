<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ä¸€é¡µç‰ˆæ—¶é—´è½´ Â· MVPï¼ˆCSV ä¸¤åˆ—å³å¯ï¼‰</title>
  <style>
    :root { --bg:#0b0c10; --panel:#11141a; --fg:#e6edf3; --muted:#93a1b3; --accent:#3ea6ff; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, Noto Sans CJK SC, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; color: var(--fg); background: linear-gradient(180deg,#0b0c10,#0b0c10 60%,#0f1218); }
    header { position: sticky; top:0; z-index: 10; background: rgba(11,12,16,0.9); backdrop-filter: blur(6px); border-bottom: 1px solid #1f2430; }
    .bar { display:flex; gap:12px; align-items:center; padding: 10px 14px; }
    .bar label { font-size: 12px; color: var(--muted); }
    .bar button, .bar input[type="file"]::file-selector-button { background: var(--panel); color: var(--fg); border:1px solid #222a36; padding:6px 10px; border-radius:10px; cursor:pointer; }
    .bar button:hover, .bar input[type="file"]::file-selector-button:hover { border-color:#2b3546; }
    .bar input[type="range"] { width:200px; }
    .wrap { display:grid; grid-template-columns: 360px 1fr; gap:0; height: calc(100vh - 56px); }
    .side { border-right: 1px solid #1f2430; background: #0f1218; padding: 12px; overflow: auto; }
    .side h3 { margin: 8px 0; font-size: 14px; color: var(--muted); }
    textarea { width:100%; height: 260px; resize: vertical; background: #0b0f16; color: var(--fg); border:1px solid #212a3a; border-radius: 12px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size: 12px; color: var(--muted); line-height: 1.4; }
    canvas { width: 100%; height: 100%; display:block; background: #0a0d12; cursor: default; }
    .hint { margin-top:10px; padding:8px 10px; border:1px dashed #2b3546; border-radius:10px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#122035; color:#a7c7ff; font-size:12px; margin-right:6px; }
    .kbd { padding:0 6px; border:1px solid #2b3546; border-radius:6px; font-size:12px; }
    /* Self-test badge */
    #testBadge { position: fixed; right: 10px; bottom: 10px; background: #0f1218; border: 1px solid #283349; border-radius: 10px; padding: 6px 10px; font-size: 12px; color: #a4c2ff; cursor: pointer; box-shadow: 0 4px 14px rgba(0,0,0,.3); }
    #testPanel { position: fixed; right: 10px; bottom: 44px; width: 380px; max-height: 45vh; overflow: auto; background: #0f1218; border: 1px solid #283349; border-radius: 12px; display: none; }
    #testPanel h4 { margin: 10px; font-size: 13px; color: #c6d4ef; }
    #testPanel pre { margin: 0 10px 10px; padding: 10px; background: #0b0f16; color: #d7e3ff; border: 1px solid #1f2a3d; border-radius: 10px; white-space: pre-wrap; }
      /* Layer å³é”®èœå• */
    #layerMenu { position: fixed; display:none; background: #0f1218; border: 1px solid #283349; border-radius: 10px; padding: 8px; box-shadow: 0 8px 20px rgba(0,0,0,.4); z-index: 20; }
    #layerMenu h5 { margin: 4px 6px 8px; font-size: 12px; color: #a4c2ff; }
    #layerMenu button { width: 180px; display:block; margin:6px 0; background:#152033; color:#e6edf3; border:1px solid #283349; border-radius:8px; padding:6px 10px; cursor:pointer; text-align:left; }
    #layerMenu button:hover { border-color:#34507a; }
    #layerMenu button.danger { background:#2a0e14; border-color:#5c1b24; color:#ffb4c0; }
      /* Layer å³é”®èœå• */
    #layerMenu { position: fixed; display:none; background: #0f1218; border: 1px solid #283349; border-radius: 10px; padding: 8px; box-shadow: 0 8px 20px rgba(0,0,0,.4); z-index: 20; }
    #layerMenu h5 { margin: 4px 6px 8px; font-size: 12px; color: #a4c2ff; }
    #layerMenu button { width: 180px; display:block; margin:6px 0; background:#152033; color:#e6edf3; border:1px solid #283349; border-radius:8px; padding:6px 10px; cursor:pointer; text-align:left; }
    #layerMenu button:hover { border-color:#34507a; }
    #layerMenu button.danger { background:#2a0e14; border-color:#5c1b24; color:#ffb4c0; }
    /* Toast */
    #toast { position: fixed; right: 12px; bottom: 12px; z-index: 30; display: none; background: #0f1218; color: #cfe1ff; border:1px solid #2b3d5c; border-radius: 10px; padding: 8px 12px; box-shadow: 0 6px 18px rgba(0,0,0,.35); }
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <label><span class="pill">æ­¥éª¤ 1</span>CSV æ–‡ä»¶ï¼ˆä¸¤åˆ—ï¼štime,titleï¼›layer å–è‡ªæ–‡ä»¶åï¼‰ï¼š</label>
      <input id="file" type="file" accept=".csv,text/csv" />
      <button id="btn-load">åŠ è½½å·¦ä¾§æ–‡æœ¬</button>
      <div style="flex:1"></div>
      <label><span class="pill">æ­¥éª¤ 2</span>æ»šè½®ç¼©æ”¾ / æ‹–æ‹½å¹³ç§»</label>
      <label>ç¼©æ”¾ï¼š<input id="zoomSlider" type="range" min="0.01" max="1000" step="0.01" value="1"></label>
      <button id="btn-reset">é‡ç½®è§†å›¾</button>
    </div>
  </header>

  <div class="wrap">
    <aside class="side">
      <h3>CSV æ–‡æœ¬ï¼ˆç¤ºä¾‹ï¼‰</h3>
      <textarea id="csvText" spellcheck="false"># time,titleï¼ˆä¸¤åˆ—ï¼›layer ç”±æ–‡ä»¶åå†³å®šï¼Œå·¦ä¾§æ–‡æœ¬é»˜è®¤å±‚åâ€œæ–‡æœ¬â€ï¼‰
# çº¦å®šï¼šèŒƒå›´ç”¨ ~ åˆ†éš”ï¼›å¯ç”¨è´Ÿæ•°è¡¨ç¤º BCEï¼ˆä¾‹ -2070~-1600ï¼‰
# è‹¥æ— ç»“æŸï¼ˆä¾‹å¦‚ 1949~ï¼‰ï¼Œå°†è‡ªåŠ¨ä»¥â€œå½“å‰å¹´â€ä»£æ›¿
-2070~-1600,å¤
-1600~-1046,å•†
-1046~-256,å‘¨
-221~-207,ç§¦
-202~8,è¥¿æ±‰
9~23,æ–°
25~220,ä¸œæ±‰
220~266,é­
221~263,èœ€æ±‰
222~280,å´
266~316,è¥¿æ™‹
317~420,ä¸œæ™‹
420~589,å—åŒ—æœ
581~618,éš‹
618~907,å”
690~705,æ­¦å‘¨
907~960,äº”ä»£
907~979,åå›½
916~1125,è¾½
960~1127,åŒ—å®‹
1127~1279,å—å®‹
1038~1227,è¥¿å¤
1115~1234,é‡‘
1271~1368,å…ƒ
1368~1644,æ˜
1636~1912,æ¸…
1912~1949,ä¸­åæ°‘å›½ï¼ˆå¤§é™†æ—¶æœŸï¼‰
1949~,ä¸­åäººæ°‘å…±å’Œå›½
</textarea>
      <div class="hint small">
        <div>æ—¶é—´å­—æ®µæ ¼å¼ï¼š</div>
        <ul>
          <li><code>start~end</code>ï¼ˆåˆ†éš”ç¬¦å¯ç”¨ <b>~ - â€” â€“ ï¼ ã€œ ï½ è‡³ åˆ°</b>ï¼›æ”¯æŒè´Ÿæ•°æˆ– 221BC/å…¬å…ƒå‰221ï¼‰</li>
          <li>å•ç‚¹ä¹Ÿå¯ï¼š<code>1054</code> ä¼šè¢«è§†ä¸º <code>1054~1054</code></li>
          <li>æ–‡ä»¶ä¸Šä¼ æ—¶ <code>layer</code> å–è‡ªæ–‡ä»¶åï¼›â€œåŠ è½½å·¦ä¾§æ–‡æœ¬â€é»˜è®¤å½’ä¸º <code>æ–‡æœ¬</code> å±‚</li>
        </ul>
        <div>æ“ä½œï¼š<span class="kbd">æ»šè½®</span> ç¼©æ”¾ï¼Œ<span class="kbd">æ‹–æ‹½</span> å¹³ç§»ï¼›<span class="kbd">Shift + æ»šè½®</span> å›´ç»•ä¸­å¿ƒç¼©æ”¾ï¼›<span class="kbd">Ctrl/Cmd + æ»šè½®</span> åŠ é€Ÿç¼©æ”¾ï¼›<b>åœ¨å·¦ä¾§å›¾å±‚åç§°åŒºåŸŸæŒ‰ä½æ‹–åŠ¨</b>å¯ä¸Šä¸‹è°ƒæ•´ layer é¡ºåºï¼›<span class="kbd">å³é”®</span> å›¾å±‚åç§°å¯åˆ é™¤è¯¥å±‚ï¼›åŒå‡»æˆ–â€œé‡ç½®è§†å›¾â€å¤ä½ã€‚</div>
      </div>
    </aside>
    <main>
      <canvas id="c"></canvas>
    </main>
  </div>

  <!-- Self-test UI -->
  <div id="testBadge" title="ç‚¹å‡»æŸ¥çœ‹è‡ªæµ‹è¯¦æƒ…" style="display:none"></div>
  <div id="testPanel">
    <h4>è‡ªæµ‹ç»“æœ</h4>
    <pre id="testLog"></pre>
  </div>
  <div id="layerMenu">
    <h5>å›¾å±‚æ“ä½œ</h5>
    <button id="menuDelete" class="danger">ğŸ—‘ åˆ é™¤è¯¥å±‚</button>
    <button id="menuCancel">å–æ¶ˆ</button>
  </div>
  <div id="toast"></div>

<script>
// =============== åŸºç¡€å·¥å…·ï¼ˆæ—¶é—´è§£æ / BCE æ˜¾ç¤ºï¼‰ ==================
const CURRENT_YEAR = new Date().getFullYear();
const MIN_PX_PER_YEAR = 0.01;   // æ›´æ·±çš„æ”¾å¤§ä¸‹é™
const MAX_PX_PER_YEAR = 1000;   // æ›´é«˜çš„æ”¾å¤§ä¸Šé™

function parseYearToken(token) {
  if (token == null) return null;
  let s = String(token).trim();
  if (!s) return null;
  // å»é™¤ BOMï¼ˆè‹¥å­˜åœ¨ï¼‰
  if (s && s.charCodeAt(0) === 0xFEFF) s = s.slice(1);
  const sUpper = s.toUpperCase();

  // 221BC / 221 BCE â†’ å¤©æ–‡å­¦å¹´å·ï¼ˆ1BCâ†’0, 2BCâ†’-1 ...ï¼‰
  let m = sUpper.match(/^(\d+)\s*(BC|BCE)$/i);
  if (m) {
    const y = parseInt(m[1], 10);
    return -(y - 1);
  }
  // å…¬å…ƒå‰221 / å‰221
  m = s.match(/^(?:å…¬å…ƒ)?å‰\s*(\d+)/i);
  if (m) {
    const y = parseInt(m[1], 10);
    return -(y - 1);
  }
  // çº¯æ•´æ•°ï¼ˆå…è®¸è´Ÿå·ï¼‰
  if (/^-?\d+$/.test(s)) return parseInt(s, 10);

  return null;
}

function parseTimeField(field) {
  let s = String(field).trim();
  if (!s) return null;
  // ä½¿ç”¨åŸºäºâ€œå¹´ä»½è®°å·â€çš„æ•´ä½“åŒ¹é…ï¼Œé¿å…æŠŠè´Ÿå·å½“ä½œåˆ†éš”ç¬¦
  const yearToken = '(?:-?\\d+|\\d+\\s*(?:BC|BCE)|(?:å…¬å…ƒ)?å‰\\s*\\d+)';
  const re = new RegExp('^\\s*(' + yearToken + ')\\s*(?:~|â€“|â€”|ï¼|-|ã€œ|ï½|è‡³|åˆ°)\\s*(' + yearToken + ')\\s*$', 'i');
  const m = s.match(re);
  if (m) {
    const start = parseYearToken(m[1]);
    let end = parseYearToken(m[2]);
    if (start == null) return null;
    if (end == null) end = CURRENT_YEAR; // å¼€åŒºé—´â†’å½“å‰å¹´
    return start <= end ? { start, end } : { start: end, end: start };
  }
  // å•ç‚¹å¹´ä»½
  const y = parseYearToken(s);
  if (y == null) return null;
  return { start: y, end: y };
}

function fmtYearForAxis(y) {
  return y < 0 ? `${-y} BC` : `${y}`; // æ˜¾ç¤ºå±‚ä¸å‡ºç° 0 å¹´
}

// =============== CSV è¯»å– ==================
function parseCSV(text, layerName = 'é»˜è®¤') {
  let t = text || '';
  if (t && t.charCodeAt(0) === 0xFEFF) t = t.slice(1); // å» BOM
  const lines = t.split(/\r?\n/); // âœ… æ­£ç¡®çš„æ¢è¡Œæ­£åˆ™
  const rows = [];
  for (const raw of lines) {
    const line = raw.trim();
    if (!line || line.startsWith('#')) continue;
    const parts = line.split(',');
    const time = (parts[0] ?? '').trim();
    const title = (parts[1] ?? '').trim();
    rows.push({ time, title, layer: layerName });
  }
  return rows;
}

// =============== äº‹ä»¶ä¸å¸ƒå±€ ==================
function rowsToEvents(rows) {
  const out = [];
  for (const r of rows) {
    const range = parseTimeField(r.time);
    if (!range) continue;
    const ev = {
      id: Math.random().toString(36).slice(2),
      title: r.title || '(æœªå‘½å)',
      start: range.start,
      end: range.end,
      layer: r.layer || 'é»˜è®¤',
    };
    out.push(ev);
  }
  return out;
}

function groupBy(arr, keyFn) {
  const m = new Map();
  for (const it of arr) {
    const k = keyFn(it);
    if (!m.has(k)) m.set(k, []);
    m.get(k).push(it);
  }
  return m;
}

function layoutLanes(events) {
  // è´ªå¿ƒåŒºé—´ç€è‰²ï¼šåŒå±‚å†…é¿å…æ°´å¹³é‡å 
  const evs = [...events].sort((a,b)=> a.start - b.start || a.end - b.end);
  const lanes = []; // æ¯ä¸ª lane çš„æœ€å³ç«¯ end
  for (const e of evs) {
    let idx = lanes.findIndex(x => x <= e.start);
    if (idx === -1) { idx = lanes.length; lanes.push(e.end); }
    else { lanes[idx] = e.end; }
    e.__lane = idx;
  }
  return { laneCount: lanes.length };
}

// =============== ç”»å¸ƒä¸äº¤äº’çŠ¶æ€ ==================
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;

const state = {
  pxPerYear: 2,            // æ¯å¹´å¤šå°‘åƒç´ ï¼ˆç¼©æ”¾ï¼‰
  viewStart: -2100,        // è§†å£å·¦ä¾§å¹´ä»½
  laneHeight: 26,
  laneGap: 6,
  layerGap: 18,
  topPad: 40,
  leftPad: 80,
  rightPad: 20,
  data: [],                // åŸå§‹äº‹ä»¶
  byLayer: new Map(),      // æ¯å±‚äº‹ä»¶
  layout: new Map(),       // æ¯å±‚çš„ laneCount
  // layer é¡ºåºæ§åˆ¶ä¸æ‹–æ‹½
  layerOrder: [],          // ç»˜åˆ¶é¡ºåºï¼ˆæŒ‰å¯¼å…¥å…ˆå + æ‰‹åŠ¨æ‹–æ‹½ï¼‰
  layers: [],              // ä¸ºå…¼å®¹æ—§ä»£ç /æµ‹è¯•ï¼Œç­‰äº layerOrder å¿«ç…§
  layerRects: new Map(),   // æ¯ä¸ªå±‚åœ¨ç”»å¸ƒä¸Šçš„çŸ©å½¢ï¼ˆç”¨äºå‘½ä¸­æµ‹è¯•ï¼‰
  drag: { active:false, layer:null, grabDy:0, mouseY:0, overlayY:0, targetIndex:0 },
};

function getLayerHeight(layer){
  const { laneCount } = state.layout.get(layer) || { laneCount: 0 };
  return laneCount * (state.laneHeight + state.laneGap) + 6;
}

function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  DPR = window.devicePixelRatio || 1;
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  draw();
}

window.addEventListener('resize', resizeCanvas);

function yearToX(year) { return state.leftPad + (year - state.viewStart) * state.pxPerYear; }
function xToYear(x) { return state.viewStart + (x - state.leftPad) / state.pxPerYear; }

function drawSingleLayer(layer, layerTop, options={}){
  const w = canvas.clientWidth;
  const events = state.byLayer.get(layer) || [];
  const { laneCount } = state.layout.get(layer) || { laneCount: 0 };
  const layerHeight = getLayerHeight(layer);
  const color = pickColorForLayer(layer);
  const ghost = options.ghost || false;
  const alpha = options.alpha ?? 1;

  // èƒŒæ™¯æ¡
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = ghost ? '#0b1523' : '#0e131b';
  ctx.fillRect(state.leftPad, layerTop, w - state.leftPad - state.rightPad, layerHeight);

  // Layer æ ‡é¢˜ï¼ˆå·¦ä¾§ï¼‰
  ctx.fillStyle = ghost ? '#84b6ff' : '#6c7f99';
  ctx.font = '13px system-ui, sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText(layer, state.leftPad - 10, layerTop + 2);

  // äº‹ä»¶
  for (const e of events) {
    const evTop = layerTop + 3 + e.__lane * (state.laneHeight + state.laneGap);
    const x1 = yearToX(e.start), x2 = yearToX(e.end);
    // å¯è§æ€§è£å‰ª
    if (x2 < 0 || x1 > w) continue;
    const rx = Math.max(x1, state.leftPad);
    const rw = Math.min(x2, w - state.rightPad) - rx;
    if (rw <= 1) continue;

    // æ¡
    ctx.fillStyle = color;
    const r = 6;
    roundRect(ctx, rx, evTop, rw, state.laneHeight-2, r);
    ctx.fill();

    // æ–‡æœ¬ï¼ˆé˜ˆå€¼ï¼‰
    if (rw > 40) {
      ctx.save();
      ctx.beginPath();
      roundRect(ctx, rx, evTop, rw, state.laneHeight-2, r);
      ctx.clip();
      ctx.fillStyle = 'white';
      ctx.font = '12px system-ui, sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      const label = `${e.title}  ${displayRange(e.start,e.end)}`; // æ ‡é¢˜åœ¨å‰ï¼Œæ—¶é—´åœ¨å
      ctx.fillText(label, rx + 10, evTop + (state.laneHeight-2)/2);
      ctx.restore();
    }
  }

  // æ‹–æ‹½æ€è™šçº¿è¾¹æ¡†
  if (ghost) {
    ctx.strokeStyle = '#5fa8ff';
    ctx.setLineDash([6,6]);
    ctx.lineWidth = 2;
    ctx.strokeRect(state.leftPad, layerTop, w - state.leftPad - state.rightPad, layerHeight);
  }

  ctx.restore();
}

// =============== æ¸²æŸ“ ==================
function pickColorForLayer(layer) {
  let h = 0; for (let i=0;i<layer.length;i++) h = (h*131 + layer.charCodeAt(i))>>>0;
  const hue = h % 360;
  return `hsl(${hue} 60% 55% / 0.85)`;
}

function chooseTickStep(pxPerYear) {
  const target = 110 / pxPerYear;
  const bases = [1,2,5];
  let p = 1;
  while (true) {
    for (const b of bases) {
      const step = b * p;
      if (step >= target) return step;
    }
    p *= 10;
  }
}

function drawAxis(width) {
  const y = state.topPad - 8;
  ctx.strokeStyle = '#2b3546';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, y);
  ctx.lineTo(width, y);
  ctx.stroke();

  const step = chooseTickStep(state.pxPerYear);
  const startYear = Math.floor(xToYear(0) / step) * step;
  const endYear = Math.ceil(xToYear(width) / step) * step;

  ctx.fillStyle = '#9fb1c9';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'alphabetic';
  ctx.font = '12px system-ui, sans-serif';

  for (let yv = startYear; yv <= endYear; yv += step) {
    const xx = yearToX(yv);
    ctx.strokeStyle = '#253045';
    ctx.beginPath();
    ctx.moveTo(xx, y);
    ctx.lineTo(xx, y-6);
    ctx.stroke();
    const label = fmtYearForAxis(yv);
    ctx.fillText(label, xx, y-8);
  }
}

function draw() {
  const w = canvas.clientWidth, h = canvas.clientHeight;
  ctx.clearRect(0,0,w,h);

  // èƒŒæ™¯
  const grd = ctx.createLinearGradient(0,0,0,h);
  grd.addColorStop(0,'#0a0d12');
  grd.addColorStop(1,'#0a0c10');
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,w,h);

  drawAxis(w);

  // è®¡ç®—æ­£å¸¸å¸ƒå±€å¹¶è®°å½•çŸ©å½¢
  state.layerRects.clear();
  const boxes = []; // æ­£å¸¸çŠ¶æ€ä¸‹çš„å±‚å¸ƒå±€
  let yCursor = state.topPad;
  for (const layer of state.layerOrder) {
    const height = getLayerHeight(layer);
    boxes.push({ layer, top:yCursor, height });
    state.layerRects.set(layer, { top:yCursor, height });
    yCursor += height + state.layerGap;
  }

  // ç»˜åˆ¶ï¼šè‹¥åœ¨æ‹–æ‹½ï¼Œåˆ™å…ˆç”»å…¶å®ƒå±‚ï¼Œå†ç”»æ‹–æ‹½å±‚ä¸æ’å…¥æŒ‡ç¤ºçº¿
  if (state.drag.active && state.drag.layer) {
    const dragged = state.drag.layer;
    const dragBox = boxes.find(b=>b.layer===dragged);
    const others = boxes.filter(b=>b.layer!==dragged);

    // å…ˆç”»å…¶å®ƒå±‚ï¼ˆåœ¨æ­£å¸¸ä½ç½®ï¼‰
    for (const b of others) drawSingleLayer(b.layer, b.top);

    // è®¡ç®—ç›®æ ‡æ’å…¥ç´¢å¼•ï¼ˆåŸºäºä¸­å¿ƒç‚¹ï¼‰
    const center = state.drag.overlayY + getLayerHeight(dragged)/2;
    let idx = 0;
    for (const b of others) {
      const mid = b.top + b.height/2;
      if (center > mid) idx++;
    }
    state.drag.targetIndex = idx; // 0..others.length

    // æ’å…¥ä½ç½®æç¤ºçº¿
    let lineY = state.topPad;
    if (others.length>0) {
      if (idx===0) lineY = others[0].top - state.layerGap/2;
      else if (idx>=others.length) lineY = others[others.length-1].top + others[others.length-1].height + state.layerGap/2;
      else lineY = others[idx].top - state.layerGap/2;
    }
    ctx.save();
    ctx.strokeStyle = '#5fa8ff';
    ctx.setLineDash([8,6]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, lineY);
    ctx.lineTo(w, lineY);
    ctx.stroke();
    ctx.restore();

    // ç”»æ‹–æ‹½ä¸­çš„å±‚ï¼ˆæ‚¬æµ®ï¼‰
    drawSingleLayer(dragged, state.drag.overlayY, { ghost:true, alpha:0.95 });
  } else {
    // éæ‹–æ‹½ï¼šæŒ‰å½“å‰é¡ºåºæ­£å¸¸ç»˜åˆ¶
    for (const b of boxes) drawSingleLayer(b.layer, b.top);
  }
}

function displayRange(a,b) {
  const A = a<0 ? `${-a}BC` : `${a}`;
  const B = b<0 ? `${-b}BC` : `${b}`;
  return `${A}~${B}`;
}

function roundRect(ctx, x, y, w, h, r) {
  const rr = Math.min(r, h/2, w/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

// =============== ç¼©æ”¾/å¹³ç§» & å±‚æ‹–æ‹½ ==================
let isPanning = false; let lastX = 0; let lastY = 0;

canvas.addEventListener('mousedown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left; const y = e.clientY - rect.top;
  // å·¦ä¾§æ ‡ç­¾åŒºåŸŸï¼šè§¦å‘å±‚æ‹–æ‹½
  if (x < state.leftPad) {
    // å‘½ä¸­å“ªä¸ªå±‚
    for (const [layer, box] of state.layerRects) {
      if (y >= box.top && y <= box.top + box.height) {
        state.drag.active = true;
        state.drag.layer = layer;
        state.drag.grabDy = y - box.top;
        state.drag.mouseY = y;
        state.drag.overlayY = box.top;
        canvas.style.cursor = 'grabbing';
        draw();
        return;
      }
    }
  }
  // å…¶å®ƒåŒºåŸŸï¼šå¹³ç§»
  isPanning = true; lastX = e.clientX; lastY = e.clientY; canvas.style.cursor = 'grabbing';
});

window.addEventListener('mouseup', ()=>{
  canvas.style.cursor = 'default';
  if (state.drag.active && state.drag.layer) {
    // æ ¹æ® targetIndex é‡æ–°æ’åº
    const layer = state.drag.layer;
    const curIdx = state.layerOrder.indexOf(layer);
    let target = state.drag.targetIndex;
    // ç§»é™¤å½“å‰å…ƒç´ åç´¢å¼•æ ¡æ­£
    const order = state.layerOrder.slice();
    order.splice(curIdx,1);
    if (target > order.length) target = order.length;
    if (target < 0) target = 0;
    order.splice(target, 0, layer);
    state.layerOrder = order;
    state.layers = state.layerOrder.slice(); // å…¼å®¹æ—§å¼•ç”¨
    // æ¸…ç†æ‹–æ‹½çŠ¶æ€
    state.drag = { active:false, layer:null, grabDy:0, mouseY:0, overlayY:0, targetIndex:0 };
    draw();
  }
  isPanning = false;
});

window.addEventListener('mousemove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left; const y = e.clientY - rect.top;
  if (state.drag.active && state.drag.layer) {
    state.drag.mouseY = y;
    state.drag.overlayY = y - state.drag.grabDy;
    draw();
    return;
  }
  if (isPanning) {
    const dx = e.clientX - lastX; lastX = e.clientX; lastY = e.clientY;
    state.viewStart -= dx / state.pxPerYear;
    draw();
    return;
  }
  // hover æç¤ºï¼šå·¦ä¾§å¯æ‹–åŠ¨
  if (x < state.leftPad) {
    for (const [layer, box] of state.layerRects) {
      if (y >= box.top && y <= box.top + box.height) { canvas.style.cursor = 'grab'; return; }
    }
  }
  canvas.style.cursor = 'default';
});

canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const centerX = rect.width / 2;
  const pivotX = e.shiftKey ? centerX : mx;              // Shift + æ»šè½®ï¼šå›´ç»•ä¸­å¿ƒç¼©æ”¾
  const speed = (e.ctrlKey || e.metaKey) ? 4 : 1;        // Ctrl/Cmd åŠ é€Ÿç¼©æ”¾
  const k = Math.pow(1.0015, -e.deltaY * speed);         // å¹³æ»‘ç¼©æ”¾ç³»æ•°
  applyZoom(pivotX, k);
}, { passive:false });

canvas.addEventListener('dblclick', ()=>{ resetView(); });

// å³é”®èœå•ï¼šåœ¨å·¦ä¾§å›¾å±‚åç§°åŒºåŸŸå³é”®ï¼Œå¼¹å‡ºâ€œåˆ é™¤è¯¥å±‚â€
const layerMenu = document.getElementById('layerMenu');
const btnMenuDelete = document.getElementById('menuDelete');
const btnMenuCancel = document.getElementById('menuCancel');
let menuLayer = null;

function showLayerMenu(x, y, layer){
  menuLayer = layer;
  // é˜²æ­¢è¶…å‡ºçª—å£
  const pad = 8;
  const vw = window.innerWidth, vh = window.innerHeight;
  const rect = { w: 196, h: 96 };
  const left = Math.min(x, vw - rect.w - pad);
  const top  = Math.min(y, vh - rect.h - pad);
  layerMenu.style.left = left + 'px';
  layerMenu.style.top  = top + 'px';
  layerMenu.style.display = 'block';
}
function hideLayerMenu(){ layerMenu.style.display = 'none'; menuLayer = null; }

canvas.addEventListener('contextmenu', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left; const y = e.clientY - rect.top;
  if (x < state.leftPad) {
    for (const [layer, box] of state.layerRects) {
      if (y >= box.top && y <= box.top + box.height) {
        e.preventDefault();
        showLayerMenu(e.clientX, e.clientY, layer);
        return;
      }
    }
  }
});

btnMenuDelete.addEventListener('click', (e)=>{
  e.preventDefault(); e.stopPropagation();
  if (!menuLayer) { hideLayerMenu(); return; }
  const target = menuLayer; // å¤åˆ¶ï¼Œé¿å… hide æ—¶æ¸…ç©º
  const ok = confirm(`ç¡®è®¤åˆ é™¤å›¾å±‚ â€œ${target}â€ å—ï¼Ÿ
ï¼ˆè¯¥å±‚åŒ…å«çš„äº‹ä»¶ä¹Ÿä¼šè¢«ç§»é™¤ï¼‰`);
  hideLayerMenu();
  if (ok) {
    const removed = deleteLayer(target);
    toast(removed ? `å·²åˆ é™¤å›¾å±‚ï¼š${target}` : `æœªæ‰¾åˆ°å›¾å±‚ï¼š${target}`);
  }
});
btnMenuCancel.addEventListener('click', ()=> hideLayerMenu());
window.addEventListener('click', (e)=>{ if (!layerMenu.contains(e.target)) hideLayerMenu(); });
layerMenu.addEventListener('contextmenu', (e)=>{ e.preventDefault(); e.stopPropagation(); });
window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') hideLayerMenu(); });

function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

function applyZoom(pivotX, k){
  const yearAtPivot = xToYear(pivotX);
  const newPx = clamp(state.pxPerYear * k, MIN_PX_PER_YEAR, MAX_PX_PER_YEAR);
  state.pxPerYear = newPx;
  state.viewStart = yearAtPivot - (pivotX - state.leftPad) / newPx;
  syncSlider();
  draw();
}

// =============== æ•°æ®è½½å…¥ä¸è§†å›¾é‡ç½® ==================
function rebuildFromState() {
  state.byLayer = groupBy(state.data, e=> e.layer || 'é»˜è®¤');
  const present = Array.from(state.byLayer.keys());
  if (!state.layerOrder || state.layerOrder.length===0) {
    state.layerOrder = present.slice();
  } else {
    for (const l of present) if (!state.layerOrder.includes(l)) state.layerOrder.push(l);
    state.layerOrder = state.layerOrder.filter(l => present.includes(l));
  }
  state.layers = state.layerOrder.slice(); // å…¼å®¹æ—§å¼•ç”¨
  state.layout = new Map();
  for (const layer of state.layerOrder) {
    const arr = state.byLayer.get(layer) || [];
    state.layout.set(layer, layoutLanes(arr));
  }
}

function deleteLayer(layer){
  if (!layer) return false;
  const before = state.data.length;
  // è¿‡æ»¤æ•°æ®ä¸é¡ºåº
  state.data = state.data.filter(e => e.layer !== layer);
  state.layerOrder = state.layerOrder.filter(l => l !== layer);
  state.layers = state.layerOrder.slice();
  rebuildFromState();
  draw(); // ä¸é‡ç½®è§†å›¾ï¼Œä¿ç•™å½“å‰ç¼©æ”¾/å¹³ç§»
  return state.data.length < before; // æ˜¯å¦çœŸçš„åˆ åˆ°äº†
}

function ingest(events) {
  state.data = state.data.concat(events); // è¿½åŠ å¯¼å…¥ï¼Œä¸è¦†ç›–
  rebuildFromState();
  resetView();
}

function resetView() {
  if (state.data.length === 0) return;
  const minY = Math.min(...state.data.map(e=>e.start));
  const maxY = Math.max(...state.data.map(e=>e.end));
  const w = canvas.clientWidth - state.leftPad - state.rightPad;
  const years = (maxY - minY) || 10;
  state.pxPerYear = clamp(w / years, MIN_PX_PER_YEAR, MAX_PX_PER_YEAR);
  state.viewStart = minY - (10 / state.pxPerYear); // å·¦ä¾§ç•™ç™½
  syncSlider();
  draw();
}

function syncSlider(){
  const slider = document.getElementById('zoomSlider');
  slider.min = String(MIN_PX_PER_YEAR);
  slider.max = String(MAX_PX_PER_YEAR);
  slider.value = String(state.pxPerYear);
}

function toast(msg){
  const el = document.getElementById('toast');
  if (!el) return; el.textContent = msg; el.style.display = 'block';
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>{ el.style.display = 'none'; }, 1500);
}

// =============== UI ç»‘å®š ==================
const file = document.getElementById('file');
file.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0];
  if (!f) return;
  const text = await f.text();
  const layerName = (f.name || 'æ–‡ä»¶').replace(/\.[^.]+$/, '');
  const rows = parseCSV(text, layerName);
  const events = rowsToEvents(rows);
  if (!events.length) {
    alert(`æœªè§£æåˆ°ä»»ä½•äº‹ä»¶ã€‚\nè¯·æ£€æŸ¥ï¼š\nâ€¢ CSV ä¸¤åˆ— time,titleï¼›\nâ€¢ åŒºé—´åˆ†éš”ç¬¦å¯ç”¨ ~ / - / â€” / è‡³ ç­‰ï¼›\nâ€¢ å¹´ä»½å¯å†™ -221 æˆ– 221BC / å…¬å…ƒå‰221ã€‚`);
    return;
  }
  ingest(events);
  e.target.value = '';
});

document.getElementById('btn-load').addEventListener('click', ()=>{
  const text = document.getElementById('csvText').value;
  const rows = parseCSV(text, 'æ–‡æœ¬');
  const events = rowsToEvents(rows);
  if (!events.length) {
    alert(`å·¦ä¾§æ–‡æœ¬æœªè§£æå‡ºäº‹ä»¶ã€‚\nç¤ºä¾‹ï¼š-2070~-1600,å¤`);
    return;
  }
  ingest(events);
});

document.getElementById('btn-reset').addEventListener('click', resetView);

document.getElementById('zoomSlider').addEventListener('input', (e)=>{
  const w = canvas.getBoundingClientRect().width;
  const centerX = w/2;
  const yearAtCenter = xToYear(centerX);
  state.pxPerYear = parseFloat(e.target.value);
  state.viewStart = yearAtCenter - (centerX - state.leftPad) / state.pxPerYear;
  draw();
});

// =============== Self-testï¼ˆè‡ªåŠ¨è¿è¡Œï¼Œä¸æ”¹å˜åŠŸèƒ½ï¼‰ ==================
function runSelfTests() {
  const T = [];
  function add(name, fn) { try { const r = fn(); T.push({ name, ok: !!r }); } catch (e) { T.push({ name, ok: false, err: String(e) }); } }

  // parseYearToken
  add('parseYearToken: -221 â†’ -221', ()=> parseYearToken(-221) === -221);
  add('parseYearToken: 221BC â†’ -220', ()=> parseYearToken('221BC') === -220);
  add('parseYearToken: å…¬å…ƒå‰221 â†’ -220', ()=> parseYearToken('å…¬å…ƒå‰221') === -220);

  // parseTimeField with range separators
  add('parseTimeField: -2070~-1600', ()=>{ const r = parseTimeField('-2070~-1600'); return r.start===-2070 && r.end===-1600; });
  add('parseTimeField: 221BC-207BC', ()=>{ const r = parseTimeField('221BC-207BC'); return r.start===-220 && r.end===-206; });
  add('parseTimeField: 221BC è‡³ 207BC', ()=>{ const r = parseTimeField('221BC è‡³ 207BC'); return r.start===-220 && r.end===-206; });
  add('parseTimeField: single 1054', ()=>{ const r = parseTimeField('1054'); return r.start===1054 && r.end===1054; });
  add('parseTimeField: single -1 (BCE)', ()=>{ const r = parseTimeField('-1'); return r.start===-1 && r.end===-1; });

  // parseCSV newline splitting
  add('parseCSV: split by \n', ()=> parseCSV('1~2,A\n3~4,B','L').length===2);
  add('parseCSV: split by \r\n', ()=> parseCSV('1~2,A\r\n3~4,B','L').length===2);
  add('parseCSV: BOM + \n', ()=> parseCSV('\uFEFF1~2,A\n3~4,B','L').length===2);

  // rowsToEvents pipeline
  add('rowsToEvents: pipeline basic', ()=> rowsToEvents(parseCSV('1~2,A','L')).length===1);

  // ingest append should not overwrite previous layers
  add('ingest: append preserves existing layers', ()=>{
    const backup = { data: state.data.slice(), layerOrder: state.layerOrder.slice(), byLayer: new Map(state.byLayer), layout: new Map(state.layout), pxPerYear: state.pxPerYear, viewStart: state.viewStart };
    try {
      const ev1 = rowsToEvents(parseCSV('1~2,A','L1')); ingest(ev1);
      const ev2 = rowsToEvents(parseCSV('3~4,B','L2')); ingest(ev2);
      const ok = state.layerOrder.includes('L1') && state.layerOrder.includes('L2');
      return ok;
    } finally {
      state.data = backup.data; state.layerOrder = backup.layerOrder; state.layers = state.layerOrder.slice(); state.byLayer = backup.byLayer; state.layout = backup.layout; state.pxPerYear = backup.pxPerYear; state.viewStart = backup.viewStart; draw();
    }
  });

  // å±‚é¡ºåºåº”å½“æŒ‰å¯¼å…¥é¡ºåºï¼ˆä¸æŒ‰å­—æ¯åºï¼‰
  add('layers order respects import sequence', ()=>{
    const backup = { data: state.data.slice(), layerOrder: state.layerOrder.slice(), byLayer: new Map(state.byLayer), layout: new Map(state.layout), pxPerYear: state.pxPerYear, viewStart: state.viewStart };
    try {
      const e1 = rowsToEvents(parseCSV('1~2,A','Z1')); ingest(e1);
      const e2 = rowsToEvents(parseCSV('3~4,B','A2')); ingest(e2);
      const i1 = state.layerOrder.indexOf('Z1'); const i2 = state.layerOrder.indexOf('A2');
      return i1 > -1 && i2 > -1 && i1 < i2; // Z1 åœ¨ A2 ä¹‹å‰
    } finally {
      state.data = backup.data; state.layerOrder = backup.layerOrder; state.layers = state.layerOrder.slice(); state.byLayer = backup.byLayer; state.layout = backup.layout; state.pxPerYear = backup.pxPerYear; state.viewStart = backup.viewStart; draw();
    }
  });

  // applyZoom çš„é”šç‚¹ä¿æŒæ€§
  add('applyZoom: preserves world at pivot', ()=>{
    const backup = { data: state.data.slice(), layerOrder: state.layerOrder.slice(), byLayer: new Map(state.byLayer), layout: new Map(state.layout), pxPerYear: state.pxPerYear, viewStart: state.viewStart };
    try {
      const rect = canvas.getBoundingClientRect();
      const pivotX = state.leftPad + Math.max(50, rect.width * 0.25);
      const before = xToYear(pivotX);
      applyZoom(pivotX, Math.pow(1.0015, -240));
      const after = xToYear(pivotX);
      return Math.abs(after - before) < 1e-6;
    } finally {
      state.data = backup.data; state.layerOrder = backup.layerOrder; state.layers = state.layerOrder.slice(); state.byLayer = backup.byLayer; state.layout = backup.layout; state.pxPerYear = backup.pxPerYear; state.viewStart = backup.viewStart; draw();
    }
  });

  // Ctrl/Cmd åŠ é€Ÿç¼©æ”¾åº”æ¯”æ™®é€šç¼©æ”¾å˜åŒ–æ›´å¤§
  add('applyZoom: ctrl/cmd speed multiplier is faster', ()=>{
    const backup = { pxPerYear: state.pxPerYear, viewStart: state.viewStart };
    try {
      const rect = canvas.getBoundingClientRect();
      const pivotX = state.leftPad + rect.width/2;
      const px0 = state.pxPerYear;
      applyZoom(pivotX, Math.pow(1.0015, -100));
      const px1 = state.pxPerYear;
      state.pxPerYear = px0; state.viewStart = backup.viewStart;
      applyZoom(pivotX, Math.pow(1.0015, -100*4));
      const px2 = state.pxPerYear;
      return Math.abs(px2 - px0) > Math.abs(px1 - px0);
    } finally {
      state.pxPerYear = backup.pxPerYear; state.viewStart = backup.viewStart; draw();
    }
  });

  // æ–°å¢ï¼šreorder é€»è¾‘å•å…ƒæµ‹è¯•
  add('reorder: move first to last', ()=>{
    const backup = state.layerOrder.slice();
    state.layerOrder = ['L1','L2','L3']; state.layers = state.layerOrder.slice();
    // æ¨¡æ‹Ÿ drop åˆ°æœ«å°¾
    const curIdx = state.layerOrder.indexOf('L1'); const order = state.layerOrder.slice();
    order.splice(curIdx,1); order.splice(order.length,0,'L1');
    state.layerOrder = order; state.layers = state.layerOrder.slice();
    const ok = JSON.stringify(state.layerOrder) === JSON.stringify(['L2','L3','L1']);
    state.layerOrder = backup; state.layers = state.layerOrder.slice();
    return ok;
  });
  // åˆ é™¤å›¾å±‚ï¼šåº”ä»æ•°æ®ä¸é¡ºåºä¸­ç§»é™¤
  add('deleteLayer: removes data and order', ()=>{
    const backup = { data: state.data.slice(), layerOrder: state.layerOrder.slice(), byLayer: new Map(state.byLayer), layout: new Map(state.layout) };
    try {
      state.data = []; state.layerOrder = []; state.layers = [];
      const a = rowsToEvents(parseCSV('1~2,A','L1'));
      const b = rowsToEvents(parseCSV('3~4,B','L2'));
      ingest(a); ingest(b);
      const hadL1 = state.layerOrder.includes('L1');
      deleteLayer('L1');
      const noL1 = !state.layerOrder.includes('L1') && Array.from(state.byLayer.keys()).every(k=>k!=='L1');
      return hadL1 && noL1 && state.data.every(e=> e.layer!=='L1');
    } finally {
      state.data = backup.data; state.layerOrder = backup.layerOrder; state.layers = state.layerOrder.slice(); state.byLayer = backup.byLayer; state.layout = backup.layout; draw();
    }
  });

  const pass = T.filter(t=>t.ok).length; const fail = T.length - pass;
  const log = T.map(t=> (t.ok? 'âœ…':'âŒ')+' '+t.name + (t.err? ('\n   '+t.err):'')).join('\n');
  console.log('[Timeline Self-tests]\n'+log);

  const badge = document.getElementById('testBadge');
  const panel = document.getElementById('testPanel');
  const pre = document.getElementById('testLog');
  pre.textContent = log;
  badge.style.display = 'block';
  badge.textContent = `è‡ªæµ‹ï¼š${pass}/${T.length} é€šè¿‡${fail? 'ï¼ˆæœ‰å¤±è´¥ï¼Œç‚¹æˆ‘çœ‹è¯¦æƒ…ï¼‰':''}`;
  badge.onclick = ()=>{ panel.style.display = panel.style.display==='none' ? 'block' : 'none'; };
}

// åˆå§‹è£…è½½ç¤ºä¾‹æ•°æ® + è¿è¡Œè‡ªæµ‹
window.addEventListener('load', ()=>{
  resizeCanvas();
  document.getElementById('btn-load').click();
  runSelfTests();
});
</script>
</body>
</html>
