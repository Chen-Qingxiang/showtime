<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>一页版时间轴 · MVP（CSV 两列即可）</title>
  <style>
    :root { --bg:#0b0c10; --panel:#11141a; --fg:#e6edf3; --muted:#93a1b3; --accent:#3ea6ff; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, Noto Sans CJK SC, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; color: var(--fg); background: linear-gradient(180deg,#0b0c10,#0b0c10 60%,#0f1218); }
    header { position: sticky; top:0; z-index: 10; background: rgba(11,12,16,0.9); backdrop-filter: blur(6px); border-bottom: 1px solid #1f2430; }
    .bar { display:flex; gap:12px; align-items:center; padding: 10px 14px; }
    .bar label { font-size: 12px; color: var(--muted); }
    .bar button, .bar input[type="file"]::file-selector-button { background: var(--panel); color: var(--fg); border:1px solid #222a36; padding:6px 10px; border-radius:10px; cursor:pointer; }
    .bar button:hover, .bar input[type="file"]::file-selector-button:hover { border-color:#2b3546; }
    .bar input[type="range"] { width:200px; }
    .wrap { display:grid; grid-template-columns: 360px 1fr; gap:0; height: calc(100vh - 56px); }
    .side { border-right: 1px solid #1f2430; background: #0f1218; padding: 12px; overflow: auto; }
    .side h3 { margin: 8px 0; font-size: 14px; color: var(--muted); }
    textarea { width:100%; height: 260px; resize: vertical; background: #0b0f16; color: var(--fg); border:1px solid #212a3a; border-radius: 12px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size: 12px; color: var(--muted); line-height: 1.4; }
    canvas { width: 100%; height: 100%; display:block; background: #0a0d12; cursor: default; }
    .hint { margin-top:10px; padding:8px 10px; border:1px dashed #2b3546; border-radius:10px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#122035; color:#a7c7ff; font-size:12px; margin-right:6px; }
    .kbd { padding:0 6px; border:1px solid #2b3546; border-radius:6px; font-size:12px; }
    /* Self-test badge */
    #testBadge { position: fixed; right: 10px; bottom: 10px; background: #0f1218; border: 1px solid #283349; border-radius: 10px; padding: 6px 10px; font-size: 12px; color: #a4c2ff; cursor: pointer; box-shadow: 0 4px 14px rgba(0,0,0,.3); }
    #testPanel { position: fixed; right: 10px; bottom: 44px; width: 380px; max-height: 45vh; overflow: auto; background: #0f1218; border: 1px solid #283349; border-radius: 12px; display: none; }
    #testPanel h4 { margin: 10px; font-size: 13px; color: #c6d4ef; }
    #testPanel pre { margin: 0 10px 10px; padding: 10px; background: #0b0f16; color: #d7e3ff; border: 1px solid #1f2a3d; border-radius: 10px; white-space: pre-wrap; }
      /* Layer 右键菜单 */
    #layerMenu { position: fixed; display:none; background: #0f1218; border: 1px solid #283349; border-radius: 10px; padding: 8px; box-shadow: 0 8px 20px rgba(0,0,0,.4); z-index: 20; }
    #layerMenu h5 { margin: 4px 6px 8px; font-size: 12px; color: #a4c2ff; }
    #layerMenu button { width: 180px; display:block; margin:6px 0; background:#152033; color:#e6edf3; border:1px solid #283349; border-radius:8px; padding:6px 10px; cursor:pointer; text-align:left; }
    #layerMenu button:hover { border-color:#34507a; }
    #layerMenu button.danger { background:#2a0e14; border-color:#5c1b24; color:#ffb4c0; }
      /* Layer 右键菜单 */
    #layerMenu { position: fixed; display:none; background: #0f1218; border: 1px solid #283349; border-radius: 10px; padding: 8px; box-shadow: 0 8px 20px rgba(0,0,0,.4); z-index: 20; }
    #layerMenu h5 { margin: 4px 6px 8px; font-size: 12px; color: #a4c2ff; }
    #layerMenu button { width: 180px; display:block; margin:6px 0; background:#152033; color:#e6edf3; border:1px solid #283349; border-radius:8px; padding:6px 10px; cursor:pointer; text-align:left; }
    #layerMenu button:hover { border-color:#34507a; }
    #layerMenu button.danger { background:#2a0e14; border-color:#5c1b24; color:#ffb4c0; }
    /* Toast */
    #toast { position: fixed; right: 12px; bottom: 12px; z-index: 30; display: none; background: #0f1218; color: #cfe1ff; border:1px solid #2b3d5c; border-radius: 10px; padding: 8px 12px; box-shadow: 0 6px 18px rgba(0,0,0,.35); }
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <label><span class="pill">步骤 1</span>CSV 文件（两列：time,title；layer 取自文件名）：</label>
      <input id="file" type="file" accept=".csv,text/csv" />
      <button id="btn-load">加载左侧文本</button>
      <div style="flex:1"></div>
      <label><span class="pill">步骤 2</span>滚轮缩放 / 拖拽平移</label>
      <label>缩放：<input id="zoomSlider" type="range" min="0.01" max="1000" step="0.01" value="1"></label>
      <button id="btn-reset">重置视图</button>
    </div>
  </header>

  <div class="wrap">
    <aside class="side">
      <h3>CSV 文本（示例）</h3>
      <textarea id="csvText" spellcheck="false"># time,title（两列；layer 由文件名决定，左侧文本默认层名“文本”）
# 约定：范围用 ~ 分隔；可用负数表示 BCE（例 -2070~-1600）
# 若无结束（例如 1949~），将自动以“当前年”代替
-2070~-1600,夏
-1600~-1046,商
-1046~-256,周
-221~-207,秦
-202~8,西汉
9~23,新
25~220,东汉
220~266,魏
221~263,蜀汉
222~280,吴
266~316,西晋
317~420,东晋
420~589,南北朝
581~618,隋
618~907,唐
690~705,武周
907~960,五代
907~979,十国
916~1125,辽
960~1127,北宋
1127~1279,南宋
1038~1227,西夏
1115~1234,金
1271~1368,元
1368~1644,明
1636~1912,清
1912~1949,中华民国（大陆时期）
1949~,中华人民共和国
</textarea>
      <div class="hint small">
        <div>时间字段格式：</div>
        <ul>
          <li><code>start~end</code>（分隔符可用 <b>~ - — – － 〜 ～ 至 到</b>；支持负数或 221BC/公元前221）</li>
          <li>单点也可：<code>1054</code> 会被视为 <code>1054~1054</code></li>
          <li>文件上传时 <code>layer</code> 取自文件名；“加载左侧文本”默认归为 <code>文本</code> 层</li>
        </ul>
        <div>操作：<span class="kbd">滚轮</span> 缩放，<span class="kbd">拖拽</span> 平移；<span class="kbd">Shift + 滚轮</span> 围绕中心缩放；<span class="kbd">Ctrl/Cmd + 滚轮</span> 加速缩放；<b>在左侧图层名称区域按住拖动</b>可上下调整 layer 顺序；<span class="kbd">右键</span> 图层名称可删除该层；双击或“重置视图”复位。</div>
      </div>
    </aside>
    <main>
      <canvas id="c"></canvas>
    </main>
  </div>

  <!-- Self-test UI -->
  <div id="testBadge" title="点击查看自测详情" style="display:none"></div>
  <div id="testPanel">
    <h4>自测结果</h4>
    <pre id="testLog"></pre>
  </div>
  <div id="layerMenu">
    <h5>图层操作</h5>
    <button id="menuDelete" class="danger">🗑 删除该层</button>
    <button id="menuCancel">取消</button>
  </div>
  <div id="toast"></div>

<script>
// =============== 基础工具（时间解析 / BCE 显示） ==================
const CURRENT_YEAR = new Date().getFullYear();
const MIN_PX_PER_YEAR = 0.01;   // 更深的放大下限
const MAX_PX_PER_YEAR = 1000;   // 更高的放大上限

function parseYearToken(token) {
  if (token == null) return null;
  let s = String(token).trim();
  if (!s) return null;
  // 去除 BOM（若存在）
  if (s && s.charCodeAt(0) === 0xFEFF) s = s.slice(1);
  const sUpper = s.toUpperCase();

  // 221BC / 221 BCE → 天文学年号（1BC→0, 2BC→-1 ...）
  let m = sUpper.match(/^(\d+)\s*(BC|BCE)$/i);
  if (m) {
    const y = parseInt(m[1], 10);
    return -(y - 1);
  }
  // 公元前221 / 前221
  m = s.match(/^(?:公元)?前\s*(\d+)/i);
  if (m) {
    const y = parseInt(m[1], 10);
    return -(y - 1);
  }
  // 纯整数（允许负号）
  if (/^-?\d+$/.test(s)) return parseInt(s, 10);

  return null;
}

function parseTimeField(field) {
  let s = String(field).trim();
  if (!s) return null;
  // 使用基于“年份记号”的整体匹配，避免把负号当作分隔符
  const yearToken = '(?:-?\\d+|\\d+\\s*(?:BC|BCE)|(?:公元)?前\\s*\\d+)';
  const re = new RegExp('^\\s*(' + yearToken + ')\\s*(?:~|–|—|－|-|〜|～|至|到)\\s*(' + yearToken + ')\\s*$', 'i');
  const m = s.match(re);
  if (m) {
    const start = parseYearToken(m[1]);
    let end = parseYearToken(m[2]);
    if (start == null) return null;
    if (end == null) end = CURRENT_YEAR; // 开区间→当前年
    return start <= end ? { start, end } : { start: end, end: start };
  }
  // 单点年份
  const y = parseYearToken(s);
  if (y == null) return null;
  return { start: y, end: y };
}

function fmtYearForAxis(y) {
  return y < 0 ? `${-y} BC` : `${y}`; // 显示层不出现 0 年
}

// =============== CSV 读取 ==================
function parseCSV(text, layerName = '默认') {
  let t = text || '';
  if (t && t.charCodeAt(0) === 0xFEFF) t = t.slice(1); // 去 BOM
  const lines = t.split(/\r?\n/); // ✅ 正确的换行正则
  const rows = [];
  for (const raw of lines) {
    const line = raw.trim();
    if (!line || line.startsWith('#')) continue;
    const parts = line.split(',');
    const time = (parts[0] ?? '').trim();
    const title = (parts[1] ?? '').trim();
    rows.push({ time, title, layer: layerName });
  }
  return rows;
}

// =============== 事件与布局 ==================
function rowsToEvents(rows) {
  const out = [];
  for (const r of rows) {
    const range = parseTimeField(r.time);
    if (!range) continue;
    const ev = {
      id: Math.random().toString(36).slice(2),
      title: r.title || '(未命名)',
      start: range.start,
      end: range.end,
      layer: r.layer || '默认',
    };
    out.push(ev);
  }
  return out;
}

function groupBy(arr, keyFn) {
  const m = new Map();
  for (const it of arr) {
    const k = keyFn(it);
    if (!m.has(k)) m.set(k, []);
    m.get(k).push(it);
  }
  return m;
}

function layoutLanes(events) {
  // 贪心区间着色：同层内避免水平重叠
  const evs = [...events].sort((a,b)=> a.start - b.start || a.end - b.end);
  const lanes = []; // 每个 lane 的最右端 end
  for (const e of evs) {
    let idx = lanes.findIndex(x => x <= e.start);
    if (idx === -1) { idx = lanes.length; lanes.push(e.end); }
    else { lanes[idx] = e.end; }
    e.__lane = idx;
  }
  return { laneCount: lanes.length };
}

// =============== 画布与交互状态 ==================
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;

const state = {
  pxPerYear: 2,            // 每年多少像素（缩放）
  viewStart: -2100,        // 视口左侧年份
  laneHeight: 26,
  laneGap: 6,
  layerGap: 18,
  topPad: 40,
  leftPad: 80,
  rightPad: 20,
  data: [],                // 原始事件
  byLayer: new Map(),      // 每层事件
  layout: new Map(),       // 每层的 laneCount
  // layer 顺序控制与拖拽
  layerOrder: [],          // 绘制顺序（按导入先后 + 手动拖拽）
  layers: [],              // 为兼容旧代码/测试，等于 layerOrder 快照
  layerRects: new Map(),   // 每个层在画布上的矩形（用于命中测试）
  drag: { active:false, layer:null, grabDy:0, mouseY:0, overlayY:0, targetIndex:0 },
};

function getLayerHeight(layer){
  const { laneCount } = state.layout.get(layer) || { laneCount: 0 };
  return laneCount * (state.laneHeight + state.laneGap) + 6;
}

function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  DPR = window.devicePixelRatio || 1;
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  draw();
}

window.addEventListener('resize', resizeCanvas);

function yearToX(year) { return state.leftPad + (year - state.viewStart) * state.pxPerYear; }
function xToYear(x) { return state.viewStart + (x - state.leftPad) / state.pxPerYear; }

function drawSingleLayer(layer, layerTop, options={}){
  const w = canvas.clientWidth;
  const events = state.byLayer.get(layer) || [];
  const { laneCount } = state.layout.get(layer) || { laneCount: 0 };
  const layerHeight = getLayerHeight(layer);
  const color = pickColorForLayer(layer);
  const ghost = options.ghost || false;
  const alpha = options.alpha ?? 1;

  // 背景条
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = ghost ? '#0b1523' : '#0e131b';
  ctx.fillRect(state.leftPad, layerTop, w - state.leftPad - state.rightPad, layerHeight);

  // Layer 标题（左侧）
  ctx.fillStyle = ghost ? '#84b6ff' : '#6c7f99';
  ctx.font = '13px system-ui, sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText(layer, state.leftPad - 10, layerTop + 2);

  // 事件
  for (const e of events) {
    const evTop = layerTop + 3 + e.__lane * (state.laneHeight + state.laneGap);
    const x1 = yearToX(e.start), x2 = yearToX(e.end);
    // 可见性裁剪
    if (x2 < 0 || x1 > w) continue;
    const rx = Math.max(x1, state.leftPad);
    const rw = Math.min(x2, w - state.rightPad) - rx;
    if (rw <= 1) continue;

    // 条
    ctx.fillStyle = color;
    const r = 6;
    roundRect(ctx, rx, evTop, rw, state.laneHeight-2, r);
    ctx.fill();

    // 文本（阈值）
    if (rw > 40) {
      ctx.save();
      ctx.beginPath();
      roundRect(ctx, rx, evTop, rw, state.laneHeight-2, r);
      ctx.clip();
      ctx.fillStyle = 'white';
      ctx.font = '12px system-ui, sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      const label = `${e.title}  ${displayRange(e.start,e.end)}`; // 标题在前，时间在后
      ctx.fillText(label, rx + 10, evTop + (state.laneHeight-2)/2);
      ctx.restore();
    }
  }

  // 拖拽态虚线边框
  if (ghost) {
    ctx.strokeStyle = '#5fa8ff';
    ctx.setLineDash([6,6]);
    ctx.lineWidth = 2;
    ctx.strokeRect(state.leftPad, layerTop, w - state.leftPad - state.rightPad, layerHeight);
  }

  ctx.restore();
}

// =============== 渲染 ==================
function pickColorForLayer(layer) {
  let h = 0; for (let i=0;i<layer.length;i++) h = (h*131 + layer.charCodeAt(i))>>>0;
  const hue = h % 360;
  return `hsl(${hue} 60% 55% / 0.85)`;
}

function chooseTickStep(pxPerYear) {
  const target = 110 / pxPerYear;
  const bases = [1,2,5];
  let p = 1;
  while (true) {
    for (const b of bases) {
      const step = b * p;
      if (step >= target) return step;
    }
    p *= 10;
  }
}

function drawAxis(width) {
  const y = state.topPad - 8;
  ctx.strokeStyle = '#2b3546';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, y);
  ctx.lineTo(width, y);
  ctx.stroke();

  const step = chooseTickStep(state.pxPerYear);
  const startYear = Math.floor(xToYear(0) / step) * step;
  const endYear = Math.ceil(xToYear(width) / step) * step;

  ctx.fillStyle = '#9fb1c9';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'alphabetic';
  ctx.font = '12px system-ui, sans-serif';

  for (let yv = startYear; yv <= endYear; yv += step) {
    const xx = yearToX(yv);
    ctx.strokeStyle = '#253045';
    ctx.beginPath();
    ctx.moveTo(xx, y);
    ctx.lineTo(xx, y-6);
    ctx.stroke();
    const label = fmtYearForAxis(yv);
    ctx.fillText(label, xx, y-8);
  }
}

function draw() {
  const w = canvas.clientWidth, h = canvas.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景
  const grd = ctx.createLinearGradient(0,0,0,h);
  grd.addColorStop(0,'#0a0d12');
  grd.addColorStop(1,'#0a0c10');
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,w,h);

  drawAxis(w);

  // 计算正常布局并记录矩形
  state.layerRects.clear();
  const boxes = []; // 正常状态下的层布局
  let yCursor = state.topPad;
  for (const layer of state.layerOrder) {
    const height = getLayerHeight(layer);
    boxes.push({ layer, top:yCursor, height });
    state.layerRects.set(layer, { top:yCursor, height });
    yCursor += height + state.layerGap;
  }

  // 绘制：若在拖拽，则先画其它层，再画拖拽层与插入指示线
  if (state.drag.active && state.drag.layer) {
    const dragged = state.drag.layer;
    const dragBox = boxes.find(b=>b.layer===dragged);
    const others = boxes.filter(b=>b.layer!==dragged);

    // 先画其它层（在正常位置）
    for (const b of others) drawSingleLayer(b.layer, b.top);

    // 计算目标插入索引（基于中心点）
    const center = state.drag.overlayY + getLayerHeight(dragged)/2;
    let idx = 0;
    for (const b of others) {
      const mid = b.top + b.height/2;
      if (center > mid) idx++;
    }
    state.drag.targetIndex = idx; // 0..others.length

    // 插入位置提示线
    let lineY = state.topPad;
    if (others.length>0) {
      if (idx===0) lineY = others[0].top - state.layerGap/2;
      else if (idx>=others.length) lineY = others[others.length-1].top + others[others.length-1].height + state.layerGap/2;
      else lineY = others[idx].top - state.layerGap/2;
    }
    ctx.save();
    ctx.strokeStyle = '#5fa8ff';
    ctx.setLineDash([8,6]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, lineY);
    ctx.lineTo(w, lineY);
    ctx.stroke();
    ctx.restore();

    // 画拖拽中的层（悬浮）
    drawSingleLayer(dragged, state.drag.overlayY, { ghost:true, alpha:0.95 });
  } else {
    // 非拖拽：按当前顺序正常绘制
    for (const b of boxes) drawSingleLayer(b.layer, b.top);
  }
}

function displayRange(a,b) {
  const A = a<0 ? `${-a}BC` : `${a}`;
  const B = b<0 ? `${-b}BC` : `${b}`;
  return `${A}~${B}`;
}

function roundRect(ctx, x, y, w, h, r) {
  const rr = Math.min(r, h/2, w/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

// =============== 缩放/平移 & 层拖拽 ==================
let isPanning = false; let lastX = 0; let lastY = 0;

canvas.addEventListener('mousedown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left; const y = e.clientY - rect.top;
  // 左侧标签区域：触发层拖拽
  if (x < state.leftPad) {
    // 命中哪个层
    for (const [layer, box] of state.layerRects) {
      if (y >= box.top && y <= box.top + box.height) {
        state.drag.active = true;
        state.drag.layer = layer;
        state.drag.grabDy = y - box.top;
        state.drag.mouseY = y;
        state.drag.overlayY = box.top;
        canvas.style.cursor = 'grabbing';
        draw();
        return;
      }
    }
  }
  // 其它区域：平移
  isPanning = true; lastX = e.clientX; lastY = e.clientY; canvas.style.cursor = 'grabbing';
});

window.addEventListener('mouseup', ()=>{
  canvas.style.cursor = 'default';
  if (state.drag.active && state.drag.layer) {
    // 根据 targetIndex 重新排序
    const layer = state.drag.layer;
    const curIdx = state.layerOrder.indexOf(layer);
    let target = state.drag.targetIndex;
    // 移除当前元素后索引校正
    const order = state.layerOrder.slice();
    order.splice(curIdx,1);
    if (target > order.length) target = order.length;
    if (target < 0) target = 0;
    order.splice(target, 0, layer);
    state.layerOrder = order;
    state.layers = state.layerOrder.slice(); // 兼容旧引用
    // 清理拖拽状态
    state.drag = { active:false, layer:null, grabDy:0, mouseY:0, overlayY:0, targetIndex:0 };
    draw();
  }
  isPanning = false;
});

window.addEventListener('mousemove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left; const y = e.clientY - rect.top;
  if (state.drag.active && state.drag.layer) {
    state.drag.mouseY = y;
    state.drag.overlayY = y - state.drag.grabDy;
    draw();
    return;
  }
  if (isPanning) {
    const dx = e.clientX - lastX; lastX = e.clientX; lastY = e.clientY;
    state.viewStart -= dx / state.pxPerYear;
    draw();
    return;
  }
  // hover 提示：左侧可拖动
  if (x < state.leftPad) {
    for (const [layer, box] of state.layerRects) {
      if (y >= box.top && y <= box.top + box.height) { canvas.style.cursor = 'grab'; return; }
    }
  }
  canvas.style.cursor = 'default';
});

canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const centerX = rect.width / 2;
  const pivotX = e.shiftKey ? centerX : mx;              // Shift + 滚轮：围绕中心缩放
  const speed = (e.ctrlKey || e.metaKey) ? 4 : 1;        // Ctrl/Cmd 加速缩放
  const k = Math.pow(1.0015, -e.deltaY * speed);         // 平滑缩放系数
  applyZoom(pivotX, k);
}, { passive:false });

canvas.addEventListener('dblclick', ()=>{ resetView(); });

// 右键菜单：在左侧图层名称区域右键，弹出“删除该层”
const layerMenu = document.getElementById('layerMenu');
const btnMenuDelete = document.getElementById('menuDelete');
const btnMenuCancel = document.getElementById('menuCancel');
let menuLayer = null;

function showLayerMenu(x, y, layer){
  menuLayer = layer;
  // 防止超出窗口
  const pad = 8;
  const vw = window.innerWidth, vh = window.innerHeight;
  const rect = { w: 196, h: 96 };
  const left = Math.min(x, vw - rect.w - pad);
  const top  = Math.min(y, vh - rect.h - pad);
  layerMenu.style.left = left + 'px';
  layerMenu.style.top  = top + 'px';
  layerMenu.style.display = 'block';
}
function hideLayerMenu(){ layerMenu.style.display = 'none'; menuLayer = null; }

canvas.addEventListener('contextmenu', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left; const y = e.clientY - rect.top;
  if (x < state.leftPad) {
    for (const [layer, box] of state.layerRects) {
      if (y >= box.top && y <= box.top + box.height) {
        e.preventDefault();
        showLayerMenu(e.clientX, e.clientY, layer);
        return;
      }
    }
  }
});

btnMenuDelete.addEventListener('click', (e)=>{
  e.preventDefault(); e.stopPropagation();
  if (!menuLayer) { hideLayerMenu(); return; }
  const target = menuLayer; // 复制，避免 hide 时清空
  const ok = confirm(`确认删除图层 “${target}” 吗？
（该层包含的事件也会被移除）`);
  hideLayerMenu();
  if (ok) {
    const removed = deleteLayer(target);
    toast(removed ? `已删除图层：${target}` : `未找到图层：${target}`);
  }
});
btnMenuCancel.addEventListener('click', ()=> hideLayerMenu());
window.addEventListener('click', (e)=>{ if (!layerMenu.contains(e.target)) hideLayerMenu(); });
layerMenu.addEventListener('contextmenu', (e)=>{ e.preventDefault(); e.stopPropagation(); });
window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') hideLayerMenu(); });

function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

function applyZoom(pivotX, k){
  const yearAtPivot = xToYear(pivotX);
  const newPx = clamp(state.pxPerYear * k, MIN_PX_PER_YEAR, MAX_PX_PER_YEAR);
  state.pxPerYear = newPx;
  state.viewStart = yearAtPivot - (pivotX - state.leftPad) / newPx;
  syncSlider();
  draw();
}

// =============== 数据载入与视图重置 ==================
function rebuildFromState() {
  state.byLayer = groupBy(state.data, e=> e.layer || '默认');
  const present = Array.from(state.byLayer.keys());
  if (!state.layerOrder || state.layerOrder.length===0) {
    state.layerOrder = present.slice();
  } else {
    for (const l of present) if (!state.layerOrder.includes(l)) state.layerOrder.push(l);
    state.layerOrder = state.layerOrder.filter(l => present.includes(l));
  }
  state.layers = state.layerOrder.slice(); // 兼容旧引用
  state.layout = new Map();
  for (const layer of state.layerOrder) {
    const arr = state.byLayer.get(layer) || [];
    state.layout.set(layer, layoutLanes(arr));
  }
}

function deleteLayer(layer){
  if (!layer) return false;
  const before = state.data.length;
  // 过滤数据与顺序
  state.data = state.data.filter(e => e.layer !== layer);
  state.layerOrder = state.layerOrder.filter(l => l !== layer);
  state.layers = state.layerOrder.slice();
  rebuildFromState();
  draw(); // 不重置视图，保留当前缩放/平移
  return state.data.length < before; // 是否真的删到了
}

function ingest(events) {
  state.data = state.data.concat(events); // 追加导入，不覆盖
  rebuildFromState();
  resetView();
}

function resetView() {
  if (state.data.length === 0) return;
  const minY = Math.min(...state.data.map(e=>e.start));
  const maxY = Math.max(...state.data.map(e=>e.end));
  const w = canvas.clientWidth - state.leftPad - state.rightPad;
  const years = (maxY - minY) || 10;
  state.pxPerYear = clamp(w / years, MIN_PX_PER_YEAR, MAX_PX_PER_YEAR);
  state.viewStart = minY - (10 / state.pxPerYear); // 左侧留白
  syncSlider();
  draw();
}

function syncSlider(){
  const slider = document.getElementById('zoomSlider');
  slider.min = String(MIN_PX_PER_YEAR);
  slider.max = String(MAX_PX_PER_YEAR);
  slider.value = String(state.pxPerYear);
}

function toast(msg){
  const el = document.getElementById('toast');
  if (!el) return; el.textContent = msg; el.style.display = 'block';
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>{ el.style.display = 'none'; }, 1500);
}

// =============== UI 绑定 ==================
const file = document.getElementById('file');
file.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0];
  if (!f) return;
  const text = await f.text();
  const layerName = (f.name || '文件').replace(/\.[^.]+$/, '');
  const rows = parseCSV(text, layerName);
  const events = rowsToEvents(rows);
  if (!events.length) {
    alert(`未解析到任何事件。\n请检查：\n• CSV 两列 time,title；\n• 区间分隔符可用 ~ / - / — / 至 等；\n• 年份可写 -221 或 221BC / 公元前221。`);
    return;
  }
  ingest(events);
  e.target.value = '';
});

document.getElementById('btn-load').addEventListener('click', ()=>{
  const text = document.getElementById('csvText').value;
  const rows = parseCSV(text, '文本');
  const events = rowsToEvents(rows);
  if (!events.length) {
    alert(`左侧文本未解析出事件。\n示例：-2070~-1600,夏`);
    return;
  }
  ingest(events);
});

document.getElementById('btn-reset').addEventListener('click', resetView);

document.getElementById('zoomSlider').addEventListener('input', (e)=>{
  const w = canvas.getBoundingClientRect().width;
  const centerX = w/2;
  const yearAtCenter = xToYear(centerX);
  state.pxPerYear = parseFloat(e.target.value);
  state.viewStart = yearAtCenter - (centerX - state.leftPad) / state.pxPerYear;
  draw();
});

// =============== Self-test（自动运行，不改变功能） ==================
function runSelfTests() {
  const T = [];
  function add(name, fn) { try { const r = fn(); T.push({ name, ok: !!r }); } catch (e) { T.push({ name, ok: false, err: String(e) }); } }

  // parseYearToken
  add('parseYearToken: -221 → -221', ()=> parseYearToken(-221) === -221);
  add('parseYearToken: 221BC → -220', ()=> parseYearToken('221BC') === -220);
  add('parseYearToken: 公元前221 → -220', ()=> parseYearToken('公元前221') === -220);

  // parseTimeField with range separators
  add('parseTimeField: -2070~-1600', ()=>{ const r = parseTimeField('-2070~-1600'); return r.start===-2070 && r.end===-1600; });
  add('parseTimeField: 221BC-207BC', ()=>{ const r = parseTimeField('221BC-207BC'); return r.start===-220 && r.end===-206; });
  add('parseTimeField: 221BC 至 207BC', ()=>{ const r = parseTimeField('221BC 至 207BC'); return r.start===-220 && r.end===-206; });
  add('parseTimeField: single 1054', ()=>{ const r = parseTimeField('1054'); return r.start===1054 && r.end===1054; });
  add('parseTimeField: single -1 (BCE)', ()=>{ const r = parseTimeField('-1'); return r.start===-1 && r.end===-1; });

  // parseCSV newline splitting
  add('parseCSV: split by \n', ()=> parseCSV('1~2,A\n3~4,B','L').length===2);
  add('parseCSV: split by \r\n', ()=> parseCSV('1~2,A\r\n3~4,B','L').length===2);
  add('parseCSV: BOM + \n', ()=> parseCSV('\uFEFF1~2,A\n3~4,B','L').length===2);

  // rowsToEvents pipeline
  add('rowsToEvents: pipeline basic', ()=> rowsToEvents(parseCSV('1~2,A','L')).length===1);

  // ingest append should not overwrite previous layers
  add('ingest: append preserves existing layers', ()=>{
    const backup = { data: state.data.slice(), layerOrder: state.layerOrder.slice(), byLayer: new Map(state.byLayer), layout: new Map(state.layout), pxPerYear: state.pxPerYear, viewStart: state.viewStart };
    try {
      const ev1 = rowsToEvents(parseCSV('1~2,A','L1')); ingest(ev1);
      const ev2 = rowsToEvents(parseCSV('3~4,B','L2')); ingest(ev2);
      const ok = state.layerOrder.includes('L1') && state.layerOrder.includes('L2');
      return ok;
    } finally {
      state.data = backup.data; state.layerOrder = backup.layerOrder; state.layers = state.layerOrder.slice(); state.byLayer = backup.byLayer; state.layout = backup.layout; state.pxPerYear = backup.pxPerYear; state.viewStart = backup.viewStart; draw();
    }
  });

  // 层顺序应当按导入顺序（不按字母序）
  add('layers order respects import sequence', ()=>{
    const backup = { data: state.data.slice(), layerOrder: state.layerOrder.slice(), byLayer: new Map(state.byLayer), layout: new Map(state.layout), pxPerYear: state.pxPerYear, viewStart: state.viewStart };
    try {
      const e1 = rowsToEvents(parseCSV('1~2,A','Z1')); ingest(e1);
      const e2 = rowsToEvents(parseCSV('3~4,B','A2')); ingest(e2);
      const i1 = state.layerOrder.indexOf('Z1'); const i2 = state.layerOrder.indexOf('A2');
      return i1 > -1 && i2 > -1 && i1 < i2; // Z1 在 A2 之前
    } finally {
      state.data = backup.data; state.layerOrder = backup.layerOrder; state.layers = state.layerOrder.slice(); state.byLayer = backup.byLayer; state.layout = backup.layout; state.pxPerYear = backup.pxPerYear; state.viewStart = backup.viewStart; draw();
    }
  });

  // applyZoom 的锚点保持性
  add('applyZoom: preserves world at pivot', ()=>{
    const backup = { data: state.data.slice(), layerOrder: state.layerOrder.slice(), byLayer: new Map(state.byLayer), layout: new Map(state.layout), pxPerYear: state.pxPerYear, viewStart: state.viewStart };
    try {
      const rect = canvas.getBoundingClientRect();
      const pivotX = state.leftPad + Math.max(50, rect.width * 0.25);
      const before = xToYear(pivotX);
      applyZoom(pivotX, Math.pow(1.0015, -240));
      const after = xToYear(pivotX);
      return Math.abs(after - before) < 1e-6;
    } finally {
      state.data = backup.data; state.layerOrder = backup.layerOrder; state.layers = state.layerOrder.slice(); state.byLayer = backup.byLayer; state.layout = backup.layout; state.pxPerYear = backup.pxPerYear; state.viewStart = backup.viewStart; draw();
    }
  });

  // Ctrl/Cmd 加速缩放应比普通缩放变化更大
  add('applyZoom: ctrl/cmd speed multiplier is faster', ()=>{
    const backup = { pxPerYear: state.pxPerYear, viewStart: state.viewStart };
    try {
      const rect = canvas.getBoundingClientRect();
      const pivotX = state.leftPad + rect.width/2;
      const px0 = state.pxPerYear;
      applyZoom(pivotX, Math.pow(1.0015, -100));
      const px1 = state.pxPerYear;
      state.pxPerYear = px0; state.viewStart = backup.viewStart;
      applyZoom(pivotX, Math.pow(1.0015, -100*4));
      const px2 = state.pxPerYear;
      return Math.abs(px2 - px0) > Math.abs(px1 - px0);
    } finally {
      state.pxPerYear = backup.pxPerYear; state.viewStart = backup.viewStart; draw();
    }
  });

  // 新增：reorder 逻辑单元测试
  add('reorder: move first to last', ()=>{
    const backup = state.layerOrder.slice();
    state.layerOrder = ['L1','L2','L3']; state.layers = state.layerOrder.slice();
    // 模拟 drop 到末尾
    const curIdx = state.layerOrder.indexOf('L1'); const order = state.layerOrder.slice();
    order.splice(curIdx,1); order.splice(order.length,0,'L1');
    state.layerOrder = order; state.layers = state.layerOrder.slice();
    const ok = JSON.stringify(state.layerOrder) === JSON.stringify(['L2','L3','L1']);
    state.layerOrder = backup; state.layers = state.layerOrder.slice();
    return ok;
  });
  // 删除图层：应从数据与顺序中移除
  add('deleteLayer: removes data and order', ()=>{
    const backup = { data: state.data.slice(), layerOrder: state.layerOrder.slice(), byLayer: new Map(state.byLayer), layout: new Map(state.layout) };
    try {
      state.data = []; state.layerOrder = []; state.layers = [];
      const a = rowsToEvents(parseCSV('1~2,A','L1'));
      const b = rowsToEvents(parseCSV('3~4,B','L2'));
      ingest(a); ingest(b);
      const hadL1 = state.layerOrder.includes('L1');
      deleteLayer('L1');
      const noL1 = !state.layerOrder.includes('L1') && Array.from(state.byLayer.keys()).every(k=>k!=='L1');
      return hadL1 && noL1 && state.data.every(e=> e.layer!=='L1');
    } finally {
      state.data = backup.data; state.layerOrder = backup.layerOrder; state.layers = state.layerOrder.slice(); state.byLayer = backup.byLayer; state.layout = backup.layout; draw();
    }
  });

  const pass = T.filter(t=>t.ok).length; const fail = T.length - pass;
  const log = T.map(t=> (t.ok? '✅':'❌')+' '+t.name + (t.err? ('\n   '+t.err):'')).join('\n');
  console.log('[Timeline Self-tests]\n'+log);

  const badge = document.getElementById('testBadge');
  const panel = document.getElementById('testPanel');
  const pre = document.getElementById('testLog');
  pre.textContent = log;
  badge.style.display = 'block';
  badge.textContent = `自测：${pass}/${T.length} 通过${fail? '（有失败，点我看详情）':''}`;
  badge.onclick = ()=>{ panel.style.display = panel.style.display==='none' ? 'block' : 'none'; };
}

// 初始装载示例数据 + 运行自测
window.addEventListener('load', ()=>{
  resizeCanvas();
  document.getElementById('btn-load').click();
  runSelfTests();
});
</script>
</body>
</html>
